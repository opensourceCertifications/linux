---
# Task file, runs on testenv. Does NOT fail; appends a JSON report.

- name: Verify each file with rpm -Vf
  become: yes
  ansible.builtin.command: "rpm -Vf {{ f }}"
  loop: "{{ corruptedFile }}"
  loop_control:
    loop_var: f
    label: "{{ f }}"
  register: verify_results
  changed_when: false
  failed_when: false

# Timestamp without gather_facts (avoid self-reference)
- name: Capture timestamp
  ansible.builtin.set_fact:
    now_ts: "{{ lookup('pipe','date -u +%Y-%m-%dT%H:%M:%SZ') }}"

# Build list of corrupted files (rc != 0)
- name: Collect corrupted files
  ansible.builtin.set_fact:
    corrupted_files: "{{ verify_results.results | selectattr('rc','ne',0) | list }}"

# Initialize entries list
- name: Init report entries
  ansible.builtin.set_fact:
    report_entries: []

# Build entries one-by-one (avoid complex Jinja)
- name: Build report entry objects
  ansible.builtin.set_fact:
    report_entries: "{{ report_entries + [ {
        'path': item.f | default(item.item, true),
        'status': 'corrupted',
        'detail': item.stdout | default(''),
        'ts': now_ts
      } ] }}"
  loop: "{{ corrupted_files }}"
  loop_control:
    label: "{{ (item.f | default(item.item, true)) | default('unknown') }}"

# Append to ~/report.json if anything to record
- name: Append entries to report.json
  ansible.builtin.include_tasks: "../utils/append_report.json.yml"
  when: report_entries | length > 0
  vars:
    report_path: "{{ ansible_env.HOME }}/report.json"
    entries: "{{ report_entries }}"

# Optional: summary
- name: Summary
  ansible.builtin.debug:
    msg:
      ok_files: "{{ verify_results.results | selectattr('rc','eq',0) | map(attribute='f') | list }}"
      corrupted_files: "{{ report_entries | map(attribute='path') | list }}"
