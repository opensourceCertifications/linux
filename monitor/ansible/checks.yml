---
# Play 1: create dynamic host group on the monitor
- name: Add host and vars
  hosts: localhost
  gather_facts: false
  vars_files:
    - "{{ playbook_dir }}/ansible_vars.yml"
  vars:
    testenv_address: "{{ lookup('env','TESTENV_ADDRESS') }}"
    work_items_out: "/tmp/ansible_vars_work_items.yml"
    target_host: "{{ testenv_address }}"
  tasks:
    - name: Add testenv_address to 'testenv'
      ansible.builtin.add_host:
        name: "{{ lookup('env', 'TESTENV_ADDRESS') }}"
        groups: testenv

    - name: Collect all check playbooks (yml + yaml)
      ansible.builtin.set_fact:
        check_playbooks: >-
          {{
            (query('ansible.builtin.fileglob', playbook_dir ~ '/checks/*.yml')
             + query('ansible.builtin.fileglob', playbook_dir ~ '/checks/*.yaml'))
            | unique | sort
          }}

    - name: Show what we found
      ansible.builtin.debug:
        var: check_playbooks

    ################################################################################
    - name: Ensure BrokenFiles is a list
      ansible.builtin.assert:
        that:
          - BrokenFiles is iterable
        fail_msg: "BrokenFiles must be a list of absolute paths."

    - name: Dedupe BrokenFiles while preserving order
      ansible.builtin.set_fact:
        broken_dedup: "{{ broken_dedup | default([]) + ([item] if item not in (broken_dedup | default([])) else []) }}"
      loop: "{{ BrokenFiles }}"

    # Optional: harvest trusted signer Key IDs on the monitor (can be overridden in group_vars)
    - name: Collect signer Key IDs from installed packages (monitor)
      ansible.builtin.shell: |
        set -euo pipefail
        rpm -qa --qf '%{SIGPGP:pgpsig}\n' 2>/dev/null \
        | awk '/Key ID/ {print tolower($3)}' | sort -u
      args:
        executable: /bin/bash
      changed_when: false
      register: keyids_raw
      when: allowed_rpm_keyids is not defined

    - name: Set allowed_rpm_keyids (monitor-derived or pre-defined)
      ansible.builtin.set_fact:
        allowed_rpm_keyids: >-
          {{ (allowed_rpm_keyids | default(keyids_raw.stdout_lines | default([]))) | list }}

    # Classification & default policies per path
    - name: Build work_items with class + policy
      vars:
        p: "{{ item }}"
        cls: >-
          {{ (p is match('^/boot/initramfs-.*\\.img$')) | ternary('initramfs',
             (p is match('^/boot/vmlinuz-')) | ternary('kernel',
             (p in ['/boot/grub2/grub.cfg','/boot/grub/grub.cfg']) | ternary('grubcfg',
             (p is match('^/boot/loader/entries/.*\\.conf$')) | ternary('bls',
             (p in ['/boot/grub2/grubenv','/boot/grub/grubenv']) | ternary('grubenv','generic'))))) }}
        pkg_like: >-
          {{ (p is search('^/usr/(bin|sbin)/') or p is match('^/boot/vmlinuz-')) | bool }}
      ansible.builtin.set_fact:
        work_items: "{{ (work_items | default([])) + [ {
          'path': p,
          'class': cls,
          'rpm_check': pkg_like,
          'latest_policy': pkg_like,
          'signer_policy': pkg_like,
          'hash_policy': 'none' } ] }}"
      loop: "{{ broken_dedup }}"
      loop_control:
        label: "{{ item }}"

    - name: Compose YAML document in-memory (safe formatting)
      ansible.builtin.set_fact:
        _work_doc:
          allowed_rpm_keyids: "{{ allowed_rpm_keyids | map('string') | map('lower') | list }}"
          work_items: "{{ work_items }}"

    - name: Validate YAML locally (optional sanity check)
      ansible.builtin.assert:
        that:
          - (_work_doc | to_nice_yaml(indent=2) | from_yaml) is mapping

    - name: Write merged vars file on monitor
      ansible.builtin.copy:
        dest: "{{ work_items_out }}"
        mode: "0644"
        content: |
          # generated by build_work_items.yml
          {{ _work_doc | to_nice_yaml(indent=2) | trim }}

    - name: Show summary
      ansible.builtin.debug:
        msg:
          - "Wrote {{ work_items | length }} work_items to {{ work_items_out }}"
          - "Allowed signer Key IDs: {{ allowed_rpm_keyids | length }}"

    # Ship it to testenv
    - name: Copy vars file to {{ target_host }}
      delegate_to: "{{ target_host }}"
      become: false
      ansible.builtin.copy:
        src: "{{ work_items_out }}"
        dest: "/tmp/work_items.yml"
        mode: "0644"

# (Optional) Play 2: sanity on testenv â€“ load the file (no checks yet)
- name: Confirm vars file present on testenv
  hosts: testenv
  gather_facts: false
  tasks:
    - name: Create work_items
      ansible.builtin.stat:
        path: /tmp/work_items.yml
      register: st
    - name: Fail message for work work_items
      ansible.builtin.assert:
        that: st.stat.exists
        fail_msg: "/tmp/work_items.yml not found on testenv"

################################################################################
####################### VARIABLE SETUP  ########################################
################################################################################

# Play 2: copy ansible_vars.yml to /tmp on testenv
- name: Push vars to testenv (native)
  hosts: testenv
  gather_facts: false
  remote_user: root
  vars_files:
    - "{{ playbook_dir }}/ansible_vars.yml"
  tasks:
    - name: Upload vars to /tmp
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/ansible_vars.yml"
        dest: /tmp/ansible_vars.yml
        mode: "0600"

    - name: Initialize /tmp/results.yml to empty JSON
      ansible.builtin.copy:
        dest: /tmp/results.yml
        content: "{}\n"
        owner: root
        group: root
        mode: "0644"

    - name: Run all check task files on testenv
      block:
        - name: Include {{ item | basename }}
          ansible.builtin.include_tasks: "{{ item }}"
          vars:
            # Handy per-check vars you can use inside each task file
            _cid: "{{ item | basename | regex_replace('\\.(yml|yaml)$', '') }}"
            _rad: "/tmp/{{ item | basename | regex_replace('\\.(yml|yaml)$', '') }}"
          loop: "{{ hostvars['localhost'].check_playbooks }}"
          loop_control:
            label: "{{ item | basename }}"

# Play 3: fetch /tmp/results.json from testenv to results/
- name: Fetch /tmp/results.yml (per check)
  hosts: testenv
  gather_facts: false
  remote_user: root
  tasks:
    - name: Download results.json from testenv
      ansible.builtin.fetch:
        src: /tmp/results.yml
        dest: "{{ playbook_dir }}/"
        flat: true
